# To run unit tests and new tests on a pull request on dev environment
# Runner CORES: https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners
# CORES relationship with nr of workers: https://learn.microsoft.com/en-us/azure/playwright-testing/concept-determine-optimal-configuration?utm_source=chatgpt.com#run-tests-locally
name: get test list

on:
  pull_request:
    branches: [main]

  # Allows us to run this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  get-matrix-for-sharding:
    runs-on: ubuntu-latest
    outputs:
      dynamic_matrix: ${{ steps.get-dynamic-matrix.outputs.dynamic-matrix }}
      test_load_distribution_json: ${{ steps.get-dynamic-matrix.outputs.test-load-distribution-json }}
    steps:
      - name: Get dynamic matrix
        uses: PramodKumarYadav/finish-tests-in-x-mins@main
        id: get-dynamic-matrix
        with:
          total-run-time-in-mins: 3
          pw-command-to-execute: "npx playwright test demo-todo-app.spec.ts"
  #   steps:
  #     - name: Checkout Repository
  #       uses: actions/checkout@v4

  #     - name: Install jq
  #       run: sudo apt-get update && sudo apt-get install -y jq
  #       shell: bash

  #     - name: Setup Node
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: 18

  #     - name: Cache Node Modules
  #       id: cache-node-modules
  #       uses: actions/cache@v3
  #       with:
  #         path: ~/.npm
  #         key: node-modules-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
  #         restore-keys: |
  #           node-modules-${{ runner.os }}-

  #     - name: Install project dependencies
  #       run: npm ci
  #       shell: bash

  #     - name: Cache Playwright Browsers
  #       id: cache-browsers
  #       uses: actions/cache@v3
  #       with:
  #         path: ~/.cache/ms-playwright
  #         key: playwright-browsers-${{ runner.os }}-${{ hashFiles('playwright.config.js', 'package-lock.json') }}
  #         restore-keys: |
  #           playwright-browsers-${{ runner.os }}-

  #     - name: Install Playwright Browsers
  #       if: steps.cache-browsers.outputs.cache-hit != 'true'
  #       run: npx playwright install --with-deps
  #       shell: bash

  #     - name: List of Playwright Tests to Run
  #       id: list-tests
  #       run: |
  #         # Run the Playwright test list command
  #         test_list=$(npx playwright test employee-service.spec.ts demo-todo-app.spec.ts --list --reporter=list 2>&1 || true)

  #         # Check if no tests were found
  #         if echo "$test_list" | grep -q "Error: No tests found."; then
  #           echo "No tests found. Setting RUNNER_COUNT to 1 and exiting gracefully."
  #           echo "RUNNER_COUNT=1" >> $GITHUB_ENV
  #           echo "RUNNER_COUNT=1" >> $GITHUB_OUTPUT
  #           exit 0
  #         fi

  #         # Debug: Display the raw data
  #         echo "RAW test_list:"
  #         echo "$test_list"

  #         # Filter output to include valid test lines starting with '['
  #         filtered_list=$(echo "$test_list" | grep -E '^\s*\[' | sed 's/^\s*//; s/\s*$//')

  #         # Convert the filtered output into a JSON array
  #         json_array=$(echo "$filtered_list" | jq -R -s 'split("\n") | map(select(length > 0))')

  #         # Debug: Display the JSON array
  #         echo "JSON array"
  #         echo "$json_array "

  #         # Save the JSON array to GITHUB_OUTPUT, ensuring proper escaping
  #         TEST_LIST=$(echo "$json_array" | jq -c)
  #         echo "TEST_LIST=$TEST_LIST" >> $GITHUB_OUTPUT
  #       shell: bash

  #     - name: Get Number of CPU Cores
  #       run: |
  #         # Determine the number of cores and calculate half the cores
  #         NUM_CORES=$(nproc) # For Linux runners
  #         HALF_CORES=$((NUM_CORES / 2))
  #         echo "Number of cores: $NUM_CORES"
  #         echo "Half of cores: $HALF_CORES"
  #         echo "HALF_CORES=$HALF_CORES" >> $GITHUB_ENV
  #       shell: bash

  #     - name: Calculate required runners
  #       run: |
  #         echo "Using the test list to calculate runners..."

  #         # Initialize variables
  #         RUNNER_COUNT=1
  #         TOTAL_TESTS_IN_A_RUNNER=0
  #         TOTAL_RUNNER_EXECUTION_TIME=0

  #         # MAX_RUN_TIME in milliseconds
  #         # MAX_RUN_TIME=$(( ${{ inputs.total-run-time-in-mins }} * 60 * 1000))
  #         MAX_RUN_TIME=5000
  #         echo "Max Run Time (ms): $MAX_RUN_TIME"

  #         # Read the JSON array
  #         test_list='${{ steps.list-tests.outputs.TEST_LIST }}'

  #         # Parse and iterate through the JSON array line by line
  #         echo "$test_list" | jq -r '.[]' | {
  #           while IFS= read -r test; do
  #             # Fetch the execution time for the test from state.json
  #             time=$(jq -r --arg test "$test" '.[$test]' state.json)

  #             # Extract the project from the test key
  #             project=$(echo "$test" | awk -F'â€º' '{print $1}' | xargs | sed 's/^\[//;s/\]$//')
  #             echo "::notice::Project: $project"

  #             # Extract the part of the test key to store in JSON (e.g., demo-todo-app.spec.ts:45:7)
  #             test_identifier=$(echo "$test" | awk -F'â€º' '{print $2}' | xargs)
  #             echo "::notice::Test Identifier: $test_identifier"

  #             if [ "$time" != "null" ]; then
  #               # Add the test time to the current runner's total
  #               if (( (TOTAL_RUNNER_EXECUTION_TIME + time) / HALF_CORES <= MAX_RUN_TIME )); then
  #                 TOTAL_RUNNER_EXECUTION_TIME=$((TOTAL_RUNNER_EXECUTION_TIME + time))
  #                 TOTAL_TESTS_IN_A_RUNNER=$((TOTAL_TESTS_IN_A_RUNNER + 1))
  #                 echo "::debug::Adding test to runner $RUNNER_COUNT: $test (${time}ms) "
  #               else
  #                 # Current runner is full; Add a new runner for the current test
  #                 echo "::notice title=Runner $RUNNER_COUNT expected run time:: Runner $RUNNER_COUNT will run $TOTAL_TESTS_IN_A_RUNNER tests using $HALF_CORES workers in approx run time: $((TOTAL_RUNNER_EXECUTION_TIME / HALF_CORES))ms"

  #                 # Reset variables for the next runner
  #                 RUNNER_COUNT=$((RUNNER_COUNT + 1))
  #                 TOTAL_TESTS_IN_A_RUNNER=1
  #                 TOTAL_RUNNER_EXECUTION_TIME=$time

  #                 echo "Adding another runner $RUNNER_COUNT for test: $test (${time}ms)"
  #               fi

  #               # Append test to the appropriate runner and project
  #               RUNNER_KEY="$RUNNER_COUNT"
  #               echo "$RUNNER_KEY"
  #               # Initialize the JSON for the runner if not already set
  #               if [ -z "${RUNNER_TESTS[$RUNNER_KEY]}" ]; then
  #                 RUNNER_TESTS["$RUNNER_KEY"]="{\"$project\": [\"$test_identifier\"]}"
  #               else
  #                 # Update the project grouping within the runner
  #                 if echo "${RUNNER_TESTS[$RUNNER_KEY]}" | jq -e ".\"$project\"" > /dev/null; then
  #                   # Append to existing project
  #                   RUNNER_TESTS["$RUNNER_KEY"]=$(echo "${RUNNER_TESTS[$RUNNER_KEY]}" | jq ".\"$project\" += [\"$test_identifier\"]")
  #                 else
  #                   # Add a new project
  #                   RUNNER_TESTS["$RUNNER_KEY"]=$(echo "${RUNNER_TESTS[$RUNNER_KEY]}" | jq ". + {\"$project\": [\"$test_identifier\"]}")
  #                 fi
  #               fi
  #             else
  #               echo "::error title=Test Not Found::Test not found in state.json ðŸ‘‰ $test "
  #               echo "::notice title=Directory Structure Updated::It seems the test directory structure was updated locally but it was not pushed to state.json."
  #               echo "::  title=Pre-commit Hook Suggestion::NOTE: Ideally, this situation can be completely avoided by adding a pre-commit hook to automatically add touched (new/updated) tests to state.json on commit. %0ARefer to the readme of this action, if you want to learn how to do this."
  #               echo "::notice title=Next Steps::For now, you can either 'run missing tests only' or 'all the tests locally' to update the state.json snapshot file and upload it again for reference. Later, implement the pre-commit hook to avoid this situation in the future."
  #               exit 1
  #             fi
  #           done

  #           # Debugging: Output the runner keys
  #           echo "Keys in RUNNER_TESTS: ${!RUNNER_TESTS[@]}"

  #           # Build the final JSON structure
  #           FINAL_JSON="{"
  #           for runner in "${!RUNNER_TESTS[@]}"; do
  #             if [[ "$FINAL_JSON" != "{" ]]; then
  #               FINAL_JSON+=","
  #             fi
  #             FINAL_JSON+="\"$runner\": $(echo "${RUNNER_TESTS[$runner]}" | jq -c)"
  #           done
  #           FINAL_JSON+="}"

  #           # Pretty-print the JSON using jq
  #           echo "Final runners JSON:"
  #           echo "$FINAL_JSON" | jq
  #           echo "runners_json=$FINAL_JSON" >> $GITHUB_OUTPUT

  #           echo "::notice title=Runner $RUNNER_COUNT expected run time:: Runner $RUNNER_COUNT will run $TOTAL_TESTS_IN_A_RUNNER tests using $HALF_CORES workers in approx run time: $((TOTAL_RUNNER_EXECUTION_TIME / HALF_CORES))ms"
  #           echo "RUNNER_COUNT=$RUNNER_COUNT" >> $GITHUB_ENV
  #           echo "RUNNER_COUNT=$RUNNER_COUNT" >> $GITHUB_OUTPUT
  #         }
  #       shell: bash

  #     - name: Generate JSON Matrix
  #       id: set-matrix
  #       run: |
  #         MATRIX_JSON="["
  #         for i in $(seq 1 $RUNNER_COUNT); do
  #           if [ $i -gt 1 ]; then
  #             MATRIX_JSON+=","
  #           fi
  #           MATRIX_JSON+="\"$i\""
  #         done
  #         MATRIX_JSON+="]"

  #         echo "Generated matrix: $MATRIX_JSON"
  #         echo "dynamic_matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
  #       shell: bash

  test:
    timeout-minutes: 60
    needs: get-matrix-for-sharding
    runs-on: ubuntu-latest
    environment: dev
    container:
      image: mcr.microsoft.com/playwright:v1.47.2-jammy
    strategy:
      fail-fast: false
      matrix:
        runner: ${{ fromJSON(needs.get-matrix-for-sharding.outputs.dynamic_matrix) }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq
        run: apt-get update && apt-get install -y jq

      - name: Mark Repository as Safe
        run: git config --global --add safe.directory $GITHUB_WORKSPACE

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install project dependencies
        run: npm ci

      - name: Run Playwright Tests for Runner ${{ matrix.runner }}
        run: |
          # Extract the test-load-distribution-json for the current runner
          TEST_LOAD_JSON='${{ needs.get-matrix-for-sharding.outputs.test_load_distribution_json }}' 
          echo "$TEST_LOAD_JSON" | jq .

          RUNNER_KEY="${{ matrix.runner }}"
          echo "$RUNNER_KEY"

          echo "Now print tests"
          RUNNER_TESTS=$(echo "$TEST_LOAD_JSON" | jq -r --arg key "$RUNNER_KEY" '.[$key]')
          echo "$RUNNER_TESTS"

          # Iterate over projects in the runner
          echo "Now print projects"
          PROJECTS=$(echo $RUNNER_TESTS | jq -r 'keys[]')
          echo "$PROJECTS"

          echo "Now we iterate over projects"
          for project in $PROJECTS; do
              # Get the test list for the current project
              TEST_LIST=$(echo $RUNNER_TESTS | jq -r --arg project "$project" '.[$project] | join(" ")')

              # Debugging outputs
              echo "Running tests for project: $project"
              echo "Tests: $TEST_LIST"

              # Run Playwright command if TEST_LIST is not empty
              # Generate a unique report name
              report_name="blob-report-$RUNNER_KEY-$project.json"
              echo "Report Name: $report_name"
              if [ -n "$TEST_LIST" ]; then
                  echo "Starting tests for project: $project at $(date)"
                  npx playwright test $TEST_LIST --project=$project --reporter=blob --output=blob-report/blob-report-$RUNNER_KEY-$project
                  # cat blob-report/blob-report-$RUNNER_KEY-$project/report.json
                  echo "finishing tests for project: $project at $(date)"
              else
                  echo "No tests to run for project: $project"
              fi
          done

      - name: Upload blob report to GitHub Actions Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          path: blob-report
          name: blob-report-${{ matrix.runner }}-chromium.json
          retention-days: 1

      - name: Upload blob report to GitHub Actions Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          path: blob-report
          name: blob-report-${{ matrix.runner }}-webkit.json
          retention-days: 1

  merge-reports:
    # Merge reports after playwright-tests, even if some shards have failed
    if: ${{ !cancelled() }}
    needs: [test]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Install dependencies
        run: npm ci

      - name: Download blob reports from GitHub Actions Artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-blob-reports
          pattern: blob-report-*
          merge-multiple: true

      - name: Merge into HTML Report
        run: npx playwright merge-reports --reporter html ./all-blob-reports

      - name: Upload HTML report
        uses: actions/upload-artifact@v4
        with:
          name: html-report--attempt-${{ github.run_attempt }}
          path: playwright-report
          retention-days: 14

  # test:
  #   timeout-minutes: 60
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout Repository
  #       uses: actions/checkout@v4
  #       with:
  #         fetch-depth: 0

  #     - name: Install jq
  #       run: sudo apt-get update && sudo apt-get install -y jq

  #     - name: Mark Repository as Safe
  #       run: git config --global --add safe.directory $GITHUB_WORKSPACE

  #     - name: Setup Node
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: 18

  #     - name: Cache Node Modules
  #       id: cache-node-modules
  #       uses: actions/cache@v3
  #       with:
  #         path: ~/.npm
  #         key: node-modules-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
  #         restore-keys: |
  #           node-modules-${{ runner.os }}-

  #     - name: Install project dependencies
  #       run: npm ci

  #     - name: Cache Playwright Browsers
  #       id: cache-browsers
  #       uses: actions/cache@v3
  #       with:
  #         path: ~/.cache/ms-playwright
  #         key: playwright-browsers-${{ runner.os }}-${{ hashFiles('playwright.config.js', 'package-lock.json') }}
  #         restore-keys: |
  #           playwright-browsers-${{ runner.os }}-

  #     - name: Install Playwright Browsers
  #       if: steps.cache-browsers.outputs.cache-hit != 'true'
  #       run: npx playwright install --with-deps

  #     - name: List of Playwright Tests to Run
  #       id: list-tests
  #       run: |
  #         # Run the Playwright test list command
  #         test_list=$(npx playwright test --list --reporter=list 2>&1 || true)

  #         # Check if no tests were found
  #         if echo "$test_list" | grep -q "Error: No tests found."; then
  #           echo "No tests found. Setting RUNNER_COUNT to 1 and exiting gracefully."
  #           echo "RUNNER_COUNT=1" >> $GITHUB_ENV
  #           echo "RUNNER_COUNT=1" >> $GITHUB_OUTPUT
  #           exit 0
  #         fi

  #         # Debug: Display the raw data
  #         echo "RAW test_list:"
  #         echo "$test_list"

  #         # Filter output to include valid test lines starting with '['
  #         filtered_list=$(echo "$test_list" | grep -E '^\s*\[' | sed 's/^\s*//; s/\s*$//')

  #         # Convert the filtered output into a JSON array
  #         json_array=$(echo "$filtered_list" | jq -R -s 'split("\n") | map(select(length > 0))')

  #         # Debug: Display the JSON array
  #         echo "JSON array:"
  #         echo "$json_array"

  #         # Save the JSON array to GITHUB_OUTPUT, ensuring proper escaping
  #         TEST_LIST=$(echo "$json_array" | jq -c)
  #         echo "TEST_LIST=$TEST_LIST" >> $GITHUB_ENV
  #         echo "TEST_LIST=$TEST_LIST" >> $GITHUB_OUTPUT

  #     - name: Get Number of CPU Cores
  #       run: |
  #         # Determine the number of cores and calculate half the cores
  #         NUM_CORES=$(nproc) # For Linux runners
  #         HALF_CORES=$((NUM_CORES / 2))
  #         echo "Number of cores: $NUM_CORES"
  #         echo "Half of cores: $HALF_CORES"

  #     - name: Use Test List
  #       run: |
  #         echo "Using the test list..."

  #         # Determine the number of cores and calculate half the cores
  #         NUM_CORES=$(nproc) # For Linux runners
  #         HALF_CORES=$((NUM_CORES / 2))
  #         echo "Number of cores: $NUM_CORES"
  #         echo "Half of cores: $HALF_CORES"

  #         # MAX_RUN_TIME in milliseconds (3 minutes)
  #         MAX_RUN_TIME=$((3 * 60 * 1000))
  #         TOTAL_TESTS_IN_A_RUNNER=0
  #         TOTAL_RUNNER_EXECUTION_TIME=0
  #         RUNNER_COUNT=1

  #         echo "Max Run Time (ms): $MAX_RUN_TIME"

  #         # Read the JSON array
  #         test_list='${{ steps.list-tests.outputs.TEST_LIST }}'

  #         # Parse and iterate through the JSON array line by line
  #         echo "$test_list" | jq -r '.[]' | {
  #           while IFS= read -r test; do
  #             # Fetch the execution time for the test from state.json
  #             time=$(jq -r --arg test "$test" '.[$test]' state.json)

  #             if [ "$time" != "null" ]; then
  #               # Add the test time to the current runner's total
  #               if (( (TOTAL_RUNNER_EXECUTION_TIME + time) / HALF_CORES <= MAX_RUN_TIME )); then
  #                 TOTAL_RUNNER_EXECUTION_TIME=$((TOTAL_RUNNER_EXECUTION_TIME + time))
  #                 TOTAL_TESTS_IN_A_RUNNER=$((TOTAL_TESTS_IN_A_RUNNER + 1))
  #                 echo "Adding test to runner $RUNNER_COUNT: $test (${time}ms)"
  #               else
  #                 # Current runner is full; Add a new runner for the current test
  #                 echo "::notice title=Runner $RUNNER_COUNT expected run time:: Runner $RUNNER_COUNT will run $TOTAL_TESTS_IN_A_RUNNER tests using $HALF_CORES workers in approx run time: $((TOTAL_RUNNER_EXECUTION_TIME / HALF_CORES))ms"

  #                 # Reset variables for the next runner
  #                 RUNNER_COUNT=$((RUNNER_COUNT + 1))
  #                 TOTAL_RUNNER_EXECUTION_TIME=$time
  #                 TOTAL_TESTS_IN_A_RUNNER=1
  #                 echo "Adding another runner $RUNNER_COUNT for test: $test (${time}ms)"
  #               fi
  #             else
  #               echo "::error title=Test Not Found::Test not found in state.json ðŸ‘‰ $test "
  #               echo "::notice title=Directory Structure Updated::It seems the test directory structure was updated locally but it was not pushed to state.json."
  #               echo "::  title=Pre-commit Hook Suggestion::NOTE: Ideally, this situation can be completely avoided by adding a pre-commit hook to automatically add touched (new/updated) tests to state.json on commit. %0ARefer to the readme of this action, if you want to learn how to do this."
  #               echo "::notice title=Next Steps::For now, you can either 'run missing tests only' or 'all the tests locally' to update the state.json snapshot file and upload it again for reference. Later, implement the pre-commit hook to avoid this situation in the future."
  #               exit 1
  #             fi
  #           done

  #           echo "::notice title=Runner $RUNNER_COUNT expected run time:: Runner $RUNNER_COUNT will run $TOTAL_TESTS_IN_A_RUNNER tests using $HALF_CORES workers in approx run time: $((TOTAL_RUNNER_EXECUTION_TIME / HALF_CORES))ms"
  #           echo "RUNNER_COUNT=$RUNNER_COUNT" >> $GITHUB_ENV
  #           echo "RUNNER_COUNT=$RUNNER_COUNT" >> $GITHUB_OUTPUT
  #         }

  #     - name: Generate JSON Matrix
  #       id: set-matrix
  #       run: |
  #         MATRIX_JSON="["
  #         for i in $(seq 1 $RUNNER_COUNT); do
  #           if [ $i -gt 1 ]; then
  #             MATRIX_JSON+=","
  #           fi
  #           MATRIX_JSON+="\"$i\""
  #         done
  #         MATRIX_JSON+="]"

  #         echo "Generated matrix: $MATRIX_JSON"
  #         echo "dynamic_matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
